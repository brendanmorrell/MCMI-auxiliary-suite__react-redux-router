{"version":3,"sources":["../src/mutuallyExclusiveProps.js"],"names":["mutuallyExclusiveOfType","propType","TypeError","exclusiveProps","length","propList","join","map","reduce","acc","prop","countProps","count","validator","mutuallyExclusiveProps","props","propName","componentName","exclusivePropCount","Object","keys","filter","Error","rest","isRequired","mutuallyExclusivePropsRequired"],"mappings":";;;qBAEwBA,uB;;;;;;AAFxB;;;;;;;;AAEe,SAASA,uBAAT,CAAiCC,QAAjC,EAA8D;AAC3E,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,UAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;AACD;;AAH0E,oCAAhBC,cAAgB;AAAhBA,kBAAgB;AAAA;;AAK3E,MAAIA,eAAeC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,UAAM,IAAIF,SAAJ,CAAc,6EAAd,CAAN;AACD;;AAED,MAAMG,WAAWF,eAAeG,IAAf,CAAoB,OAApB,CAAjB;;AAEA,MAAMC,MAAMJ,eAAeK,MAAf,CAAsB,UAACC,GAAD,EAAMC,IAAN;AAAA,wCAAqBD,GAArB,sBAA2BC,IAA3B,EAAkC,IAAlC;AAAA,GAAtB,EAAiE,EAAjE,CAAZ;AACA,MAAMC,aAAa,SAAbA,UAAa,CAACC,KAAD,EAAQF,IAAR;AAAA,WAAkBE,SAASL,IAAIG,IAAJ,IAAY,CAAZ,GAAgB,CAAzB,CAAlB;AAAA,GAAnB;;AAEA,MAAMG;AAAY,aAASC,sBAAT,CAAgCC,KAAhC,EAAuCC,QAAvC,EAAiDC,aAAjD,EAAyE;AACzF,UAAMC,qBAAqBC,OAAOC,IAAP,CAAYL,KAAZ,EACxBM,MADwB,CACjB;AAAA,eAAQN,MAAML,IAAN,KAAe,IAAvB;AAAA,OADiB,EAExBF,MAFwB,CAEjBG,UAFiB,EAEL,CAFK,CAA3B;AAGA,UAAIO,qBAAqB,CAAzB,EAA4B;AAC1B,eAAO,IAAII,KAAJ,eAAeL,aAAf,2DAA0EZ,QAA1E,EAAP;AACD;;AANwF,yCAANkB,IAAM;AAANA,YAAM;AAAA;;AAOzF,aAAOtB,2BAASc,KAAT,EAAgBC,QAAhB,EAA0BC,aAA1B,SAA4CM,IAA5C,EAAP;AACD;;AARK,WAAqBT,sBAArB;AAAA,KAAN;;AAUAD,YAAUW,UAAV;AAAuB,aAASC,8BAAT,CACrBV,KADqB,EAErBC,QAFqB,EAGrBC,aAHqB,EAKrB;AACA,UAAMC,qBAAqBC,OAAOC,IAAP,CAAYL,KAAZ,EACxBM,MADwB,CACjB;AAAA,eAAQX,SAASM,QAAT,IAAqBD,MAAML,IAAN,KAAe,IAA5C;AAAA,OADiB,EAExBF,MAFwB,CAEjBG,UAFiB,EAEL,CAFK,CAA3B;AAGA,UAAIO,qBAAqB,CAAzB,EAA4B;AAC1B,eAAO,IAAII,KAAJ,eAAeL,aAAf,2DAA0EZ,QAA1E,EAAP;AACD;;AAND,yCADGkB,IACH;AADGA,YACH;AAAA;;AAOA,aAAOtB,2BAASc,KAAT,EAAgBC,QAAhB,EAA0BC,aAA1B,SAA4CM,IAA5C,EAAP;AACD;;AAbD,WAAgCE,8BAAhC;AAAA;;AAeA,SAAO,gCAAcZ,SAAd,qCAAmDR,QAAnD,GAA+DF,cAA/D,CAAP;AACD","file":"mutuallyExclusiveProps.js","sourcesContent":["import wrapValidator from './helpers/wrapValidator';\n\nexport default function mutuallyExclusiveOfType(propType, ...exclusiveProps) {\n  if (typeof propType !== 'function') {\n    throw new TypeError('a propType is required');\n  }\n\n  if (exclusiveProps.length < 1) {\n    throw new TypeError('at least one prop that is mutually exclusive with this propType is required');\n  }\n\n  const propList = exclusiveProps.join(', or ');\n\n  const map = exclusiveProps.reduce((acc, prop) => ({ ...acc, [prop]: true }), {});\n  const countProps = (count, prop) => (count + (map[prop] ? 1 : 0));\n\n  const validator = function mutuallyExclusiveProps(props, propName, componentName, ...rest) {\n    const exclusivePropCount = Object.keys(props)\n      .filter(prop => props[prop] != null)\n      .reduce(countProps, 0);\n    if (exclusivePropCount > 1) {\n      return new Error(`A ${componentName} cannot have more than one of these props: ${propList}`);\n    }\n    return propType(props, propName, componentName, ...rest);\n  };\n\n  validator.isRequired = function mutuallyExclusivePropsRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const exclusivePropCount = Object.keys(props)\n      .filter(prop => prop === propName || props[prop] != null)\n      .reduce(countProps, 0);\n    if (exclusivePropCount > 1) {\n      return new Error(`A ${componentName} cannot have more than one of these props: ${propList}`);\n    }\n    return propType(props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, `mutuallyExclusiveProps:${propList}`, exclusiveProps);\n}\n"]}