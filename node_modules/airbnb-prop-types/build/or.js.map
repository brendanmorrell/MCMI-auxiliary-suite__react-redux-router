{"version":3,"sources":["../src/or.js"],"names":["or","oneOfTypeValidator","validators","validator","oneOfType","props","propName","componentName","rest","errors","map","v","filter","Boolean","length","TypeError","isRequired","oneOfTypeRequired","name","Array","isArray","RangeError"],"mappings":";;;qBAmCwBA,E;;AAnCxB;;AACA;;;;;;;;AAEA,SAASC,kBAAT,CAA4BC,UAA5B,EAAwC;AACtC,MAAMC;AAAY,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,aAApC,EAA4D;AAAA,wCAANC,IAAM;AAANA,YAAM;AAAA;;AAC5E,UAAI,OAAOH,MAAMC,QAAN,CAAP,KAA2B,WAA/B,EAA4C;AAC1C,eAAO,IAAP;AACD;;AAED,UAAMG,SAASP,WACZQ,GADY,CACR;AAAA,eAAKC,oBAAEN,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAL;AAAA,OADQ,EAEZI,MAFY,CAELC,OAFK,CAAf;;AAIA,UAAIJ,OAAOK,MAAP,GAAgBZ,WAAWY,MAA/B,EAAuC;AACrC,eAAO,IAAP;AACD;AACD,aAAO,IAAIC,SAAJ,QAAiBR,aAAjB,4CAA6DD,QAA7D,QAAP;AACD;;AAbK,WAAqBF,SAArB;AAAA,KAAN;AAcAD,YAAUa,UAAV;AAAuB,aAASC,iBAAT,CAA2BZ,KAA3B,EAAkCC,QAAlC,EAA4CC,aAA5C,EAAoE;AAAA,yCAANC,IAAM;AAANA,YAAM;AAAA;;AACzF,UAAI,OAAOH,MAAMC,QAAN,CAAP,KAA2B,WAA/B,EAA4C;AAC1C,eAAO,IAAIS,SAAJ,QAAiBR,aAAjB,6CAA8DD,QAA9D,QAAP;AACD;;AAED,UAAMG,SAASP,WACZQ,GADY,CACR;AAAA,eAAKC,oBAAEN,KAAF,EAASC,QAAT,EAAmBC,aAAnB,SAAqCC,IAArC,EAAL;AAAA,OADQ,EAEZI,MAFY,CAELC,OAFK,CAAf;;AAIA,UAAIJ,OAAOK,MAAP,KAAkBZ,WAAWY,MAAjC,EAAyC;AACvC,eAAO,IAAIC,SAAJ,QAAiBR,aAAjB,gCAAiDE,MAAjD,sCAAgFH,QAAhF,QAAP;AACD;AACD,aAAO,IAAP;AACD;;AAbD,WAAgCW,iBAAhC;AAAA;AAcA,SAAO,gCAAcd,SAAd,EAAyB,WAAzB,EAAsCD,UAAtC,CAAP;AACD;;AAEc,SAASF,EAAT,CAAYE,UAAZ,EAAqC;AAAA,MAAbgB,IAAa,uEAAN,IAAM;;AAClD,MAAI,CAACC,MAAMC,OAAN,CAAclB,UAAd,CAAL,EAAgC;AAC9B,UAAM,IAAIa,SAAJ,CAAc,uCAAd,CAAN;AACD;AACD,MAAIb,WAAWY,MAAX,IAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIO,UAAJ,CAAe,uCAAf,CAAN;AACD;;AAED,MAAMlB,YAAYF,oBAChB,wBAAQA,mBAAmBC,UAAnB,CAAR,CADgB,4BAEbA,UAFa,GAAlB;;AAKA,SAAO,gCAAcC,SAAd,EAAyBe,IAAzB,EAA+BhB,UAA/B,CAAP;AACD","file":"or.js","sourcesContent":["import { arrayOf } from 'prop-types';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction oneOfTypeValidator(validators) {\n  const validator = function oneOfType(props, propName, componentName, ...rest) {\n    if (typeof props[propName] === 'undefined') {\n      return null;\n    }\n\n    const errors = validators\n      .map(v => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length < validators.length) {\n      return null;\n    }\n    return new TypeError(`${componentName}: invalid value supplied to ${propName}.`);\n  };\n  validator.isRequired = function oneOfTypeRequired(props, propName, componentName, ...rest) {\n    if (typeof props[propName] === 'undefined') {\n      return new TypeError(`${componentName}: missing value for required ${propName}.`);\n    }\n\n    const errors = validators\n      .map(v => v(props, propName, componentName, ...rest))\n      .filter(Boolean);\n\n    if (errors.length === validators.length) {\n      return new TypeError(`${componentName}: invalid value ${errors} supplied to required ${propName}.`);\n    }\n    return null;\n  };\n  return wrapValidator(validator, 'oneOfType', validators);\n}\n\nexport default function or(validators, name = 'or') {\n  if (!Array.isArray(validators)) {\n    throw new TypeError('or: 2 or more validators are required');\n  }\n  if (validators.length <= 1) {\n    throw new RangeError('or: 2 or more validators are required');\n  }\n\n  const validator = oneOfTypeValidator([\n    arrayOf(oneOfTypeValidator(validators)),\n    ...validators,\n  ]);\n\n  return wrapValidator(validator, name, validators);\n}\n"]}